/**
 * @file hand_loader.cpp
 * @brief Implementation of JSON data loaders.
 * * Handles I/O operations for reading static mesh data (baked JSON) 
 * and dynamic tracking data (IPC JSON) using nlohmann/json.
 */

#include "hand_loader.h"
#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

/**
 * @brief Loads real-time tracking data from the IPC shared file.
 * * @param filename Path to the JSON file generated by the Python tracker.
 * @return std::vector<DetectedHand> List of detected hands in the current frame.
 * * @note This function uses a non-blocking read attempt. If the file is locked
 * or malformed (race condition), it returns an empty vector or the previous state.
 */
std::vector<DetectedHand> load_hand_data(const char* filename) {
    std::vector<DetectedHand> hands;
    std::ifstream file(filename);
    
    if (!file.is_open()) return hands;

    try {
        // Check for empty file to prevent parse errors during write operations
        if (file.peek() == std::ifstream::traits_type::eof()) return hands;
        
        json data; 
        file >> data;

        if (data.is_array()) {
            for (const auto& h_entry : data) {
                DetectedHand dh;
                // Default to Right if label is missing
                dh.label = h_entry.value("label", "Right");
                
                for (const auto& p : h_entry["landmarks"]) {
                    dh.points.push_back({
                        p["x"].get<float>(),
                        p["y"].get<float>(),
                        p["z"].get<float>()
                    });
                }
                hands.push_back(dh);
            }
        }
    } catch (...) {
        // Suppress parsing exceptions caused by atomic write race conditions
    }
    return hands;
}

/**
 * @brief Loads the static MANO mesh topology.
 * * Reads vertices, faces, and pre-calculated skinning vectors. 
 * This should be called once during initialization.
 */
SkinnedMesh load_skinned_mesh(const char* filename) {
    SkinnedMesh mesh;
    std::ifstream file(filename);
    
    if (!file.is_open()) {
        std::cerr << "[Error] Failed to load mesh: " << filename << std::endl;
        return mesh;
    }

    json data; 
    file >> data;

    // Load topology (triangles)
    for (const auto& f : data["faces"]) {
        mesh.faces.push_back({f[0], f[1], f[2]});
    }

    // Load geometry and skinning weights
    for (const auto& v : data["vertices"]) {
        mesh.vertices.push_back({
            v["bid"], v["len"], v["proj"],
            v["px"], v["py"], v["pz"],
            v["nx"], v["ny"], v["nz"],
            v["rvx"], v["rvy"], v["rvz"]
        });
    }
    return mesh;
}